#!/usr/bin/perl
#
# === About
#
# Templer is a template-expansion program I use for my websites, which
# allows per-page and global templates to be used, along with variable
# interpolation and simple conditionals.
#
# We allow interpolation, etc, into the output of our pages by the
# use of the M<HTML::Template> module.
#
# The name?  It stuck.  Initially I was thinking "templator" and
# "Templer" popped into my mind, via Knights Templer.
#
#
# === Live Usage
#
# This code is in use in three domains I host:
#
# =over 8
#
# =item stolen-souls.com
#
# =item blogspam.net
#
# =item steve.org.uk
#
# =back
#
# Over time it has evolved to become reasonably non-Steve-specific, but if you
# have queries please do get in touch.
#
#
# === Structure
#
# A site consists of a configuration file C<templer.cfg> and an input
# directory.  Input files are expanded through L<HTML::Template>, to
# expand any variables set in the top of a file, and then the contents
# are inserted into a global layout template
#
# There are two modes of operation for the generated files:
#
#   * In-place
#     Files are processed and the suffix is replaced with .html
#
#   * Output Path
#     Files are generated in a distinct output-tree, and any static
#     assets such as JPG, GIF, PNG, CSS, and JS files are copied across too
#
#
# === Code Layout
#
#  Templer::Global
#    - Contains global configuration file parsing.  ("templer.cfg")
#
#  Templer::Site
#    - Given an input directory it will return objects of the type:
#
#       Templer::Site::Asset
#        - An item which requires zero expansion.  Media, javascript, etc.
#
#       Templer::Site::Page
#       - A page which requires template expansion.
#
#
# Note #1: The command-line options override those specified in the global object.
#
# Note #2: The global object has sensible defaults.
#
#
#
# === Questions / Bug Reports
#
# Please get in touch.
#
# Steve
# --
#


use strict;
use warnings;

use File::Copy;
use File::Find;
use File::Path qw! mkpath !;
use Getopt::Long;
use HTML::Template;
use Pod::Usage;




#
#  A package for reading the global configuration file.
#
#  We assume that every project contains a "./templer.cfg" file in the
# top-level directory.  Here we parse that, if present.
#
package Templer::Global;

sub new
{
    my ( $proto, %supplied ) = (@_);
    my $class = ref($proto) || $proto;

    my $self = {};

    #
    #  Allow user supplied values to override our defaults
    #
    foreach my $key ( keys %supplied )
    {
        $self->{ lc $key } = $supplied{ $key };
    }

    bless( $self, $class );
    $self->_readGlobalCFG( $self->{ 'file' } ) if ( $self->{ 'file' } );
    return $self;
}


sub _readGlobalCFG
{
    my ( $self, $filename ) = (@_);

    #
    #  If the global configuration file doesn't exist that's a shame.
    #
    return if ( !-e $filename );

    open( my $handle, "<:utf8", $filename ) or
      die "Failed to read '$filename' - $!";
    binmode( $handle, ":utf8" );

    while ( my $line = <$handle> )
    {
        chomp($line);
        next if ( $line =~ /^#/ );

        if ( $line =~ /^(.*)=(.*)$/ )
        {
            my $key = $1;
            my $val = $2;
            $key = lc($key);
            $key =~ s/^\s+|\s+$//g;
            $val =~ s/^\s+|\s+$//g;

            $self->{ $key } = $val;

            print "Templer::Global set: $key => $val\n"
              if ( $self->{ 'debug' } );
        }
    }
    close($handle);
}



#
# Retrieve a value from the file, by key.
#
sub field
{
    my ( $self, $field ) = (@_);
    return ( $self->{ $field } );
}


#
# Retrieve all known key/value pairs.
#
sub fields
{
    my ($self) = (@_);

    %$self;
}


#
# Return the global-layout file.
#
sub layout
{
    my ($self) = (@_);
    $self->field("layout");
}




#
# This object holds data about each asset which was found.
#
# An asset is anything in the input directory which is *not* a page.
#
# Assuming we're not running in "in-place" mode then assets are copied
# over to a suitable filename in the output tree.
#
package Templer::Site::Asset;



#
# Constructor
#
sub new
{
    my ( $proto, %supplied ) = (@_);
    my $class = ref($proto) || $proto;

    my $self = {};

    #
    #  Allow user supplied values to override our defaults
    #
    foreach my $key ( keys %supplied )
    {
        $self->{ lc $key } = $supplied{ $key };
    }

    bless( $self, $class );
    return $self;
}


#
# The source of the asset.
#
sub source
{
    my ($self) = (@_);
    $self->{ "file" };
}




#
# This object holds data about each page.
#
# A page is any file in the input-directory which matches the pattern
# "*.skx", and is not a directory.
#
# Pages are processed via the M<HTML::Template> module to create the
# suitable output.
#
package Templer::Site::Page;



#
# Constructor
#
sub new
{
    my ( $proto, %supplied ) = (@_);
    my $class = ref($proto) || $proto;

    my $self = {};

    #
    #  Allow user supplied values to override our defaults
    #
    foreach my $key ( keys %supplied )
    {
        $self->{ lc $key } = $supplied{ $key };
    }

    bless( $self, $class );
    $self->_readFile( $self->{ 'file' } ) if ( $self->{ 'file' } );
    return $self;
}


#
# Read the file, and parse the header/content.
#
sub _readFile
{
    my ( $self, $filename ) = (@_);

    open( my $handle, "<:utf8", $filename ) or
      die "Failed to read '$filename' - $!";
    binmode( $handle, ":utf8" );

    my $header = 1;

    while ( my $line = <$handle> )
    {
        chomp($line);
        if ($header)
        {
            if ( $line =~ /^(.*):(.*)$/ )
            {
                my $key = $1;
                my $val = $2;
                $key = lc($key);
                $key =~ s/^\s+|\s+$//g;
                $val =~ s/^\s+|\s+$//g;

                $self->{ $key } = $val;
                print "Templer::Site::Page set: $key => $val\n"
                  if ( $self->{ 'debug' } );
            }
            if ( $line =~ /^----$/ )
            {
                $header = undef;
            }
        }
        else
        {
            $self->{ 'content' } .= $line . "\n";
        }
    }
    close($handle);
}


#
# Return the body of the page.
#
# Here is where we'd do markdown expansion if we wished.
#
sub content
{
    my ($self) = (@_);
    return ( $self->{ 'content' } );
}


#
# Retrieve a field from the header of the page.
#
sub field
{
    my ( $self, $field ) = (@_);
    return ( $self->{ $field } );
}


#
# Return all known fields/values from the page.
#
sub fields
{
    my ($self) = (@_);

    %$self;
}


#
#  Return the filename we were built from.
#
sub source
{
    my ($self) = (@_);
    $self->field("file");
}


#
# Return the per-page layout file to use, if present.
#
sub layout
{
    my ($self) = (@_);
    $self->field("layout");
}




#
# This class encapsulates a site.
#
# A site is comprised of "pages" and "assets".
#
# =over 8
#
# =item Pages
#
# Pages are things which are template expanded.
#
# =item Assets
#
# Assets are files that are merely copied from the input directory to
# the output path.  If we're running in "in-place" mode then they are
# ignored.
#
# =back
#
# This class contains helpers for finding and returning arrays of
# both such objects.
#
package Templer::Site;



#
# Constructor
#
sub new
{
    my ( $proto, %supplied ) = (@_);
    my $class = ref($proto) || $proto;

    my $self = {};

    #
    #  Allow user supplied values to override our defaults
    #
    foreach my $key ( keys %supplied )
    {
        $self->{ lc $key } = $supplied{ $key };
    }

    bless( $self, $class );
    return $self;
}


#
# A site comprises of a collection of pages and
# a collection of static resources which aren't
# touched/modified - these are "assets".
#
# Return an object for each page.
#
sub pages
{
    my ( $self, %args ) = (@_);

    my $dir    = $args{ 'directory' } || $self->{ 'directory' };
    my $suffix = $args{ 'suffix' }    || $self->{ 'suffix' };

    return (
             $self->_findFiles( must_match => $suffix . "\$",
                                object     => "Templer::Site::Page",
                                directory  => $dir
                              ) );
}


#
# A site comprises of a collection of pages and
# a collection of static resources which aren't
# touched/modified - these are "assets".
#
# Return an object for each asset we find.
#
sub assets
{
    my ( $self, %args ) = (@_);

    my $dir    = $args{ 'directory' } || $self->{ 'directory' };
    my $suffix = $args{ 'suffix' }    || $self->{ 'suffix' };

    return (
             $self->_findFiles( must_not_match => $suffix . "\$",
                                object         => "Templer::Site::Asset",
                                directory      => $dir
                              ) );

}


#
# Find files in the given directory and return a new object
# for each one.
#
# We assume that the object can be constructed and receives
# a single hash with "file => $name".
#
sub _findFiles
{
    my ( $self, %args ) = (@_);

    #
    #  Files we've found.  Ignoring the suffix just now.
    #
    my @files;

    File::Find::find( {
           wanted => sub {
               push( @files, $File::Find::name )
                 if ( !-d $File::Find::name );
           },
           follow      => 1,
           follow_skip => 2,
           no_chdir    => 1
        },
        $args{ 'directory' } );

    #
    #  OK now we need to find the matches.
    #
    my @matches;

    my $class = $args{ 'object' };

    if ( $args{ 'must_match' } )
    {
        foreach my $file (@files)
        {
            next unless ( $file =~ /$args{'must_match'}/ );
            push( @matches, $class->new( file => $file ) );
        }
    }
    elsif ( $args{ 'must_not_match' } )
    {
        foreach my $file (@files)
        {
            next if ( $file =~ /$args{'must_not_match'}/ );
            push( @matches, $class->new( file => $file ) );
        }
    }
    @matches;
}




####
##
#  Entry point to the code.
##
########



package main;


#
#  Configuration variables
#
my %CONFIG;




#
#  Parse the command line.
#
exit
  if (
    !GetOptions(

        # Help options
        "help",   \$CONFIG{ 'help' },
        "manual", \$CONFIG{ 'manual' },

        # In/out/in-place
        "input=s",       \$CONFIG{ 'input' },
        "output=s",      \$CONFIG{ 'output' },
        "in-place",      \$CONFIG{ 'in-place' },
        "layout-path=s", \$CONFIG{ 'layout-path' },

        # Flags - force a rebuild
        "force",   \$CONFIG{ 'force' },
        "verbose", \$CONFIG{ 'verbose' },
    ) );


#
#  Help/Manual handling.
#
pod2usage(1) if ( $CONFIG{ 'help' } );
pod2usage( -verbose => 2 ) if ( $CONFIG{ 'manual' } );


#
#  Read the global configuration file.
#
my $cfg = Templer::Global->new( file => "./templer.cfg" );

#
#  Create a site helper - telling it what suffix to use, unless
# that was specified in the global configuration file.
#
my $suffix = $cfg->field("suffix") || ".skx";
my $site = Templer::Site->new( suffix => $suffix );


#
#  The input directory to process, and output path.
#
#  [The command line takes precedence.  Always]
#
my $in  = $CONFIG{ 'input' }  || $cfg->field("input")  || "./input/";
my $out = $CONFIG{ 'output' } || $cfg->field("output") || "./output/";
my $inplace = $CONFIG{ 'in-place' } || $cfg->field("in-place");


#
#  Ensure we have an input directory.
#
if ( !-d $in )
{
    print "The input directory doesn't exist: $in\n";
    exit;
}


#
#  The template path, and default template
#
my $tpath = $CONFIG{ 'layout-path' } ||
  $cfg->field("layout-path") ||
  "./layouts";
my $dtemplate = $CONFIG{ 'layout' } ||
  $cfg->field("layout") ||
  "default.layout";



#
#  Create the output directory if missing, unless we're in-place
#
mkpath( $out, { verbose => 0, mode => oct(755) } )
  if ( !-d $out && ( !$CONFIG{ 'in-place' } ) );


#
#  Find all pages & assets.
#
my @pages = $site->pages( directory => $in );
my @assets = $site->assets( directory => $in );

#
# Count of pages we've built.
#
my $rebuilt = 0;

#
#  For each page we've found.
#
foreach my $page (@pages)
{
    my $src = $page->source();
    print "\nProcessing page: $src\n" if ( $CONFIG{ 'verbose' } );

    #
    # Convert the input path to a suitable output path.
    #
    my $dst = $src;
    $dst =~ s/$suffix/.html/g;
    $dst =~ s/$in/$out/g unless ($inplace);

    #
    # Show the transformation.
    #
    print "File: $src\n" if ( $CONFIG{ 'verbose' } );
    print "Dest: $dst\n" if ( $CONFIG{ 'verbose' } );


    #
    # The template to expand the content into will come from the page, or the global
    # configuration
    #
    my $template = $page->layout() || $cfg->layout() || $dtemplate;
    print "Layout file is: $tpath/$template\n" if ( $CONFIG{ 'verbose' } );

    #
    # Ensure the template exists.
    #
    if ( !-e $tpath . "/" . $template )
    {
        print "Layout missing: $tpath/$template\n";
        next;
    }


    #
    #  If the destination is missing or old then we must rebuild.
    #
    my $rebuild = 0;
    if ( !-e $dst )
    {
        $rebuild = 1;
        print "Forcing rebuild because $dst is missing.\n"
          if ( $CONFIG{ 'verbose' } );
    }
    else
    {
        if ( -M $src < -M $dst )
        {
            print "Rebuilding as page is newer than the output.\n"
              if ( $CONFIG{ 'verbose' } );
            $rebuild = 1;
        }
        else
        {
            if ( -M $dst > -M $tpath . "/" . $template )
            {
                print "Rebuilding as output is older than the layout.\n"
                  if ( $CONFIG{ 'verbose' } );
                $rebuild = 1;
            }
        }
    }


    #
    # Is the rebuild being forced?
    #
    $rebuild = 1 if ( $CONFIG{ 'force' } );

    #
    #  Skip this page if we don't need to build it.
    #
    next unless ($rebuild);

    #
    # Keep track of rebuilt pages.
    #
    $rebuilt += 1;


    #
    #  Load the HTML::Template module against the layout.
    #
    my $tmpl = HTML::Template->new( filename => $tpath . "/" . $template,
                                    die_on_bad_params      => 0,
                                    search_path_on_include => 1,
                                    path                   => $tpath,
                                  );


    #
    #  Load the HTLM::Template module against the body of the page.
    #
    #  Includes are relative to the path of the input
    #
    my $dirName = $page->source();
    if ( $dirName =~ /^(.*)\/(.*)$/ )
    {
        $dirName = $1;
    }
    my $body = HTML::Template->new( scalarref              => \$page->content(),
                                    die_on_bad_params      => 0,
                                    search_path_on_include => 1,
                                    path                   => $dirName
                                  );


    #
    #  The template-data we'll expand for the page/template.
    #
    my %data = ( $cfg->fields(), $page->fields() );

    #
    #  If any key contains "read_file()" then read the file.
    #
    foreach my $var ( keys %data )
    {
        if ( $data{ $var } =~ /^read_file\((.*)\)/ )
        {
            my $file = $1;
            $file =~ s/['"]//g;
            $file =~ s/^\s+|\s+$//g;

            if ( $file eq "SELF" )
            {
                $file = $src;
            }
            else
            {
                $file = $dirName . "/" . $file;
            }

            $data{ $var } = read_file($file);
        }
        if ( $data{ $var } =~ /^run_command\((.*)\)/ )
        {
            my $cmd = $1;
            $cmd =~ s/['"]//g;
            $cmd =~ s/^\s+|\s+$//g;
            $data{ $var } = `$cmd`;
        }
        if ( $data{ $var } =~ /^file_glob\((.*)\)/ )
        {
            my $pattern = $1;
            $pattern =~ s/['"]//g;
            $pattern =~ s/^\s+|\s+$//g;

            # add the data
            my $ref;
            foreach my $img ( glob( $dirName . "/" . $pattern ) )
            {

                # remove dirname
                $img = substr( $img, length( $dirName . "/" ) );
                push( @$ref, { file => $img } );
            }
            $data{ $var } = $ref;
        }
    }

    #
    #  Template-expand the body of the page.
    #
    $body->param( \%data );
    $data{ 'content' } = $body->output();


    #
    # Make the (updated) global and per-page data available
    # to the template object.
    #
    $tmpl->param( \%data );

    #
    # Make sure the output directory exists
    #
    my $path = $dst;
    if ( $path =~ /^(.*)\/(.*)$/ )
    {
        $path = $1;
        mkpath( $path, { verbose => 0, mode => oct(755) } ) if ( !-d $path );
    }

    #
    #  Output the expanded template to the destination file.
    #
    print "Writing to $dst\n" if ( $CONFIG{ 'verbose' } );
    open my $handle, ">:utf8", $dst or die "Failed to write to '$dst' - $!";
    binmode( $handle, ":utf8" );
    print $handle $tmpl->output();
    close $handle;
}


#
#  Now copy all missing assets into place.
#
my $copied = 0;

foreach my $asset (@assets)
{

    #
    # If we're running "in-place" then we don't need to
    # copy assets.
    #
    next if ($inplace);

    #
    # Work out the input-> output change.
    #
    my $src = $asset->source();
    my $dst = $src;
    $dst =~ s/$in/$out/g;

    my $path = $dst;
    if ( $path =~ /^(.*)\/(.*)$/ )
    {
        $path = $1;
        mkpath( $path, { verbose => 0, mode => oct(755) } ) if ( !-d $path );
    }

    #
    # Do the copy
    #
    copy( $src, $dst );
    $copied += 1;
}



print "\nAll done: $rebuilt page(s) updated\n";
print "Copied $copied asset(s)\n" unless ($inplace);

exit(0);


#
# Helper for meta-data expansion:
#
#   Foo: read_file( "/etc/passwd" )
#
sub read_file
{
    my ($name) = (@_);

    my $content = "";

    if ( -e $name )
    {
        open( my $handle, "<:utf8", $name ) or
          die "Failed to read '$name' - $!";
        binmode( $handle, ":utf8" );

        while ( my $line = <$handle> )
        {
            $content .= $line;
        }
        close($handle);
    }
    else
    {
        print "WARNING: Failed to read $name\n";
    }
    $content;
}
