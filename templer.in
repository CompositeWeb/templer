#!/usr/bin/perl
#
#  Documentation at the foot of the script.
#

use strict;
use warnings;

use File::Path qw! mkpath !;
use Getopt::Long;
use Pod::Usage;




####
##
#  Entry point to the code.
##
########



package main;




#
#  Configuration variables
#
my %CONFIG;


#
#  Parse the command line.
#
parseCommandLine();


#
#  Test that we have required dependencies.
#
testDependencies();


#
#  If we're not in a templer-directory then go up the filesystem
# looking for one.  Stop after "a few" attempts.
#
for ( my $count = 0 ; $count < 5 ; $count += 1 )
{
    if ( !( ( -e "templer.cfg" ) || ( -d "input/" ) ) )
    {
        chdir("../");
    }
}

#
#  Read the global configuration file.
#
my $cnf = $CONFIG{ 'config' } || "./templer.cfg";
my $cfg = Templer::Global->new( file => $cnf );

#
#  Create a site helper - telling it what suffix to look for to
# identify pages.
#
my $suffix = $cfg->field("suffix") || ".skx";
my $site = Templer::Site->new( suffix => $suffix );


#
#  The input directory to process, and output path.
#
#  [The command line takes precedence.  Always.]
#
my $in  = $CONFIG{ 'input' }  || $cfg->field("input")  || "./input/";
my $out = $CONFIG{ 'output' } || $cfg->field("output") || "./output/";
my $inplace = $CONFIG{ 'in-place' } || $cfg->field("in-place");


#
#  Ensure we have an input directory.
#
if ( !-d $in )
{
    print "The input directory doesn't exist: $in\n";
    exit;
}


#
#  Start a HTTP server
#
if ( $CONFIG{ 'serve' } )
{

    #
    # Document root
    #
    my $root = $out;
    $root = $in if ( defined $inplace && $inplace );

    if ( !-d $root )
    {
        print "Document root doesn't exist: $root\n";
        exit 0;
    }

    #
    #  This is appalling.
    #
    my $port = $CONFIG{ 'serve' } || "8000";
    system("cd $root && python -m SimpleHTTPServer $port");
    exit(0);
}


#
#  The template path, and default template to use for layout.
#
my $tpath = $CONFIG{ 'layout-path' } ||
  $cfg->field("layout-path") ||
  "./layouts";
my $dtemplate = $CONFIG{ 'layout' } ||
  $cfg->field("layout") ||
  "default.layout";


#
#  The plugin path, and include path.
#
my $ppath = $CONFIG{ 'plugin-path' } ||
  $cfg->field("plugin-path") ||
  "./plugins";
my $ipath = $CONFIG{ 'include-path' } ||
  $cfg->field("include-path") ||
  "./includes";

#
#  If we have a plugin directory then load the plugins beneath it.
#
#  NOTE:  The bundled/built-in plugins will always be available.
#
my $PLUGINS = Templer::Plugin::Factory->new();
if ( -d $ppath )
{
    $PLUGINS->load_plugins($ppath);
}

#
#  Setup an array of include-paths.
#
my @INCLUDES;
foreach my $path ( split( /:/, $ipath ) )
{
    push( @INCLUDES, $path ) if ( -d $path );
}
$cfg->set( "include-path", \@INCLUDES );



#
#  Execute any pre-build commands the user might have defined.
#
runCommands('pre-build');


#
#  Create the output directory if missing, unless we're in-place
#
File::Path::mkpath( $out, { verbose => 0, mode => oct(755) } )
  if ( !-d $out && ( !$inplace ) );


#
#  Record the start time.
#
my $timer = Templer::Timer->new();


#
#  Find all pages & assets.
#
my @pages = $site->pages( directory => $in );
my @assets = $site->assets( directory => $in );

#
# Count of pages we've built.
#
my $rebuilt = 0;

#
#  For each page we've found.
#
foreach my $page (@pages)
{

    #
    # The path of the page, on-disk.
    #
    my $src = $page->source();

    print "\nProcessing page: $src\n" if ( $CONFIG{ 'verbose' } );

    #
    # Convert the input path to a suitable output path.
    #
    my $dst = $src;
    $dst =~ s/$suffix/.html/g;
    $dst =~ s/^$in/$out/g unless ($inplace);

    #
    # Show the transformation.
    #
    print "File: $src\n" if ( $CONFIG{ 'verbose' } );
    print "Dest: $dst\n" if ( $CONFIG{ 'verbose' } );


    #
    # The template to expand the content into will come from the page, or the global
    # configuration
    #
    my $template = $page->layout() || $cfg->layout() || $dtemplate;
    print "Layout file is: $tpath/$template\n" if ( $CONFIG{ 'verbose' } );

    #
    # Ensure the template exists.
    #
    if ( !-e $tpath . "/" . $template )
    {
        print "WARNING: Layout file missing: $tpath/$template\n";
        next;
    }


    #
    #  If the destination is missing or old then we must rebuild.
    #
    my $rebuild = 0;
    if ( !-e $dst )
    {
        $rebuild = 1;
        print "Forcing rebuild because $dst is missing.\n"
          if ( $CONFIG{ 'verbose' } );
    }
    else
    {
        if ( -M $src < -M $dst )
        {
            print "Rebuilding as page is newer than the output.\n"
              if ( $CONFIG{ 'verbose' } );
            $rebuild = 1;
        }
        else
        {
            if ( -M $dst > -M $tpath . "/" . $template )
            {
                print "Rebuilding as output is older than the layout.\n"
                  if ( $CONFIG{ 'verbose' } );
                $rebuild = 1;
            }
        }
    }


    #
    # Is the rebuild being forced?
    #
    $rebuild = 1 if ( $CONFIG{ 'force' } );

    #
    #  Skip this page if we don't need to build it.
    #
    next unless ($rebuild);


    #
    # Keep track of rebuilt pages.
    #
    $rebuilt += 1;


    #
    #  Load the HTML::Template module against the layout.
    #
    my $tmpl = HTML::Template->new( filename => $tpath . "/" . $template,
                                    die_on_bad_params => 0,
                                    path              => [@INCLUDES, $tpath],
                                    search_path_on_include => 1,
                                    global_vars            => 1,
                                    loop_context_vars      => 1,
                                  );



    #
    #  The template-data we'll expand for the page/template.
    #
    my %data = ( $cfg->fields(), $page->fields() );

    #
    #  Use the plugin-factory to expand each of the variables.
    #
    my $ref = $PLUGINS->expand_variables( $cfg, $page, \%data );
    %data = %$ref;


    #
    #  Load the HTLM::Template module against the body of the page.
    #
    #  (Includes are relative to the path of the input.)
    #
    my $dirName = $page->source();
    if ( $dirName =~ /^(.*)\/(.*)$/ )
    {
        $dirName = $1;
    }
    my $body = HTML::Template->new( scalarref => \$page->content( \%data ),
                                    die_on_bad_params => 0,
                                    path              => [@INCLUDES, $dirName],
                                    search_path_on_include => 1,
                                    global_vars            => 1,
                                    loop_context_vars      => 1,
                                  );


    #
    #  Template-expand the body of the page.
    #
    $body->param( \%data );
    $data{ 'content' } = $body->output();


    #
    # Make the (updated) global and per-page data available
    # to the template object.
    #
    $tmpl->param( \%data );

    #
    # Make sure the output path exists.
    #
    my $path = $dst;
    if ( $path =~ /^(.*)\/(.*)$/ )
    {
        $path = $1;
        File::Path::mkpath( $path, { verbose => 0, mode => oct(755) } )
          if ( !-d $path );
    }

    #
    #  Output the expanded template to the destination file.
    #
    print "Writing to $dst\n" if ( $CONFIG{ 'verbose' } );
    open my $handle, ">:utf8", $dst or die "Failed to write to '$dst' - $!";
    binmode( $handle, ":utf8" );
    print $handle $tmpl->output();
    close $handle;
}


#
#  Now copy all missing assets into place, unless we're running in-place.
#
unless ($inplace)
{

    #
    #  The files we're going to copy.
    #
    my @copy;


    #
    # We're going to build-up a command line to pass to tar
    #
    foreach my $asset (@assets)
    {

        #
        # Strip the input component of the filename(s).
        #
        my $src = $asset->source();
        $src =~ s/^$in//g;

        #
        # If we've got an asset which is a directory that
        # is already present, for example, we'll skip it.
        #
        push( @copy, $src ) unless ( -e "$out/$src" );
    }

    #
    # Run the copy, unless all files are present.
    #
    if ( scalar @copy ne 0 )
    {

        #
        # The horrible command we're going to execute.
        #
        my $cmd = "(cd $in && tar -cf - " .
          join( " ", @copy ) . ") | ( cd $out && tar xf -)";
        print "TAR: $cmd " if ( $CONFIG{ 'verbose' } );
        system($cmd );
    }
}



#
#  Cleanup any plugins.
#
$PLUGINS->cleanup();


#
#  See if we have post-build commands
#
runCommands("post-build");




#
# All done.
#
my $duration = $timer->elapsed();
print "\nAll done: $rebuilt page(s) updated in $duration.\n"
  unless ( $CONFIG{ 'quiet' } );

exit(0);




#
#  Parse the command line
#
sub parseCommandLine
{

    #
    #  Parse the command line.
    #
    exit
      if (
        !Getopt::Long::GetOptions(

            # Help options
            "help",   \$CONFIG{ 'help' },
            "manual", \$CONFIG{ 'manual' },

            # In/out/in-place
            "config=s",       \$CONFIG{ 'config' },
            "input=s",        \$CONFIG{ 'input' },
            "output=s",       \$CONFIG{ 'output' },
            "in-place",       \$CONFIG{ 'in-place' },
            "include-path=s", \$CONFIG{ 'include-path' },
            "layout-path=s",  \$CONFIG{ 'layout-path' },
            "plugin-path=s",  \$CONFIG{ 'plugin-path' },

            # Flags - force a rebuild
            "force",   \$CONFIG{ 'force' },
            "serve=i", \$CONFIG{ 'serve' },
            "quiet",   \$CONFIG{ 'quiet' },
            "verbose", \$CONFIG{ 'verbose' },
        ) );


    #
    #  Help/Manual handling.
    #
    Pod::Usage::pod2usage( -input => \*DATA ) if ( $CONFIG{ 'help' } );
    Pod::Usage::pod2usage( -input => \*DATA, -verbose => 2 )
      if ( $CONFIG{ 'manual' } );


}


#
#  Test for required dependencies
#
sub testDependencies
{
    my $fatal = 0;

    #
    #  The required modules
    #
    foreach my $module (qw!  HTML::Template !)
    {
        my $eval = "use $module;";

        ## no critic (Eval)
        eval($eval);
        ## use critic
        if ($@)
        {
            print "The $module module doesn't seem to be installed.\n";
            $fatal = 1;
        }
    }

    exit(1) if ($fatal);
}


#
# Run the commands the user might have specified for pre-build/post-build
# execution
#
sub runCommands
{
    my ($type) = (@_);

    my $cmds = $cfg->field($type);
    if ($cmds)
    {
        foreach my $cmd (@$cmds)
        {
            $CONFIG{ 'verbose' } && print "$type command: $cmd\n";
            system($cmd );
        }
    }
}

__DATA__

=head1 NAME

templer - A static-site generator, written in perl.

=cut

=head1 SYNOPSIS

  templer [options]


  Help Options:

    --help        Show the help information for this script.
    --manual      Read the manual for this script.

  Path options:

    --input          Specify the input directory to process.
    --output         Specify the output directory to build the site to.
    --layout-path    Specify the location from which to find layouts.
    --plugin-path    Specify the location from which to load plugins.

  Flags

    --force          Force a rebuild of all pages.
    --in-place       Specify we're processing pages in-place, ignoring the output dir.
    --quiet          Don't show output.
    --verbose        Be noisy during the execution.

=cut

=head1 ABOUT

Templer is the static-site generator utility I use for my websites.

Templer flexible with input pages, and allows variables to be defined
on a global or per-page basis, and then inserted into the output.

Given a single template a complete site may be generated with an arbitrary
number of pages, each sharing a common look and feel.  If required you can
define a range of templates and select which to use on a per-page basis.

We allow variable interpolation, loops, and conditional expansion in the
generated output via the use of the L<HTML::Template> module.

The name?  It stuck.  Initially I was thinking "templator" and
"Templer" popped into my mind, via Knights Templer.

=cut

=head1 Live Usage

This code is in use in three domains I host:

=over 8

=item http://stolen-souls.com/

=item http://blogspam.net/

=item http://steve.org.uk/

=back

Initially there was one version of the C<templer> tool, but slowly the three sites
required different tweaks and we had three different versions of the site-generator.

The version you're seeing now is unified, containing all the previously site-specific
changes.  On that basis it should be generally flexible and usable by others.

=cut


=head1 Site Structure

A templer-based site consists of a configuration file C<templer.cfg> and
an input directory.  Input files are expanded through L<HTML::Template>, to
expand any variables set in the pages themselves, or in the global template.
Once page-content is expanded it is then inserted into a global layout template.

There are two modes of operation when it comes to processing fiels:

=over 8

=item "In-place"

Files are processed and the suffix is replaced with .html

=item Output Path

Files are generated in a distinct output-tree, and any static
assets such as JPG, GIF, PNG, CSS, and JS files are copied across too.

=back

This allows you to run in-place in your C<~/public_html> directory or to
setup an output path which is later synced to your final/live location.

=cut


=head1 Code Layout

The implementation uses several simple classes, mostly as wrappers around
variable parsing:

=over 8

=item Templer::Global

This contains the parsing code for the  global configuration file, which is
located at the top-level directory of the site.  (It must be named
C<templer.cfg>).

=item Templer::Site

Given an input directory this module finds and returns C<Templer::Site::Asset> and
C<Templer::Site::Page> objects for each file present.

=item Templer::Site::Asset

An item which requires zero expansion.  Media, javascript, etc.

=item Templer::Site::Page

A page which requires template expansion.

=back

Note #1: The command-line options override those specified in the global object.

Note #2: The global object has sensible defaults.

=cut

=head1 Questions / Bug Reports

The code is developed and hosted on gitub in the following location:

=over 8

=item https://github.com/skx/templer

=back

Please raise any issues in the tracker there.

=cut

=head1 LICENSE

This module is free software; you can redistribute it and/or modify it
under the terms of either:

a) the GNU General Public License as published by the Free Software
Foundation; either version 2, or (at your option) any later version,
or

b) the Perl "Artistic License".

=cut

=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2012-2013 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut

